# Source global bashrc
    [ -f /etc/bashrc ] && source /etc/bashrc

# Enable programmable completion features
    [ -f /etc/bash_completion ] && ! shopt -oq posix && source /etc/bash_completion

# Set Shell options to increase functionality
    shopt -s autocd               # Enable changing directory without cd
    shopt -s cdspell              # Spelling correction for cd
    shopt -s checkwinsize         # Adjust text to window size after commands
    shopt -s dirspell             # Spelling correction for dirs
    shopt -s dotglob              # Enable globbing for dotfiles
    shopt -s extglob              # Extended globbing
    shopt -s globstar             # ZSH-like ** globbing (recursive dir match)
    shopt -s histappend           # Append to history, don't overwrite
    shopt -s histreedit           # Re-edit failed history substitutions
    shopt -s nocaseglob           # Ignore cases for globbing filenames

# Source common shell config
    XDG_CONFIG_HOME="$(dirname ${BASH_SOURCE[0]})/.."
    [ -f "$XDG_CONFIG_HOME/bash/xdg.sh" ] && source "$XDG_CONFIG_HOME/bash/xdg.sh"

# For Git
    export GIT_PS1_SHOWDIRTYSTATE=1
    export GIT_PS1_SHOWUPSTREAM="auto"

# History
    export HISTCONTROL=ignoreboth:erasedups
    export HISTSIZE=10000
    export HISTFILESIZE=10000

# Other
    bind Space:magic-space
    # export TERM=xterm-256color

    # have to press ctrl+d twice to close terminal
    # export IGNOREEOF=1

    # save commandline history after every command
    if [[ ${PROMPT_COMMAND} != *"history -a"* ]]; then
        export PROMPT_COMMAND="history -a;${PROMPT_COMMAND}"
    fi

## Enable commands for fzf ** completion
    complete -F _fzf_path_completion -o default -o bashdefault bcompare
    complete -F _fzf_path_completion -o default -o bashdefault mc

# Load Aliases and Functions
    [ -f "$XDG_CONFIG_HOME/bash/aliases.sh" ] && source "$XDG_CONFIG_HOME/bash/aliases.sh"

# Load completions
    for file in "$XDG_CONFIG_HOME/bash/completions/"*; do
        if [ ! -z "$(type -P ${file##*/})" ]
        then
            source "${file}"
        fi
    done

# Set default editor
    export EDITOR="vim"
    export VISUAL=$EDITOR

# Custom command prompt
    function setMyPrompt()
    {
        local GREEN="\[\033[0;32m\]"
        local CYAN="\[\033[0;36m\]"
        local RED="\[\033[0;31m\]"
        local PURPLE="\[\033[0;35m\]"
        local YELLOW="\[\033[0;33m\]"
        local BROWN="\[\033[0;33m\]"
        local LIGHT_GRAY="\[\033[0;37m\]"
        local LIGHT_BLUE="\[\033[1;34m\]"
        local LIGHT_GREEN="\[\033[1;32m\]"
        local LIGHT_CYAN="\[\033[1;36m\]"
        local LIGHT_RED="\[\033[1;31m\]"
        local LIGHT_PURPLE="\[\033[1;35m\]"
        local LIGHT_YELLOW="\[\033[1;33m\]"
        local WHITE="\[\033[1;37m\]"
        local RESTORE="\[\033[0m\]"

        local windowTitle="\[\e]0;\u@\h: \w\a\]"
        local chrootLocation="${debian_chroot}"
        local newLine="\n"
        local returnCode="[\$?]"
        local userAndHost="\u@\h"
        local path="\w"
        local gitPrompt='$(__git_ps1 "(%s) " 2>/dev/null)'
        local virtualEnvName='${VIRTUAL_ENV:+($(basename "${VIRTUAL_ENV}")) }'
        local tail="\\$"

        export PS1="${windowTitle}${newLine}${returnCode} ${virtualEnvName}${chrootLocation:+${RED}${chrootLocation} }${LIGHT_GREEN}${userAndHost} ${MSYSTEM:+${PURPLE}${MSYSTEM} }${LIGHT_BLUE}${path} ${YELLOW}${gitPrompt}${RESTORE}${tail} "
    }

    setMyPrompt

