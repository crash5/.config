" vim: foldmethod=marker

set viminfo='100,<1000,s100,h

" XDG path config {{{
if !empty($XDG_DATA_HOME)
    set undodir=$XDG_DATA_HOME/vim/undo//
    set directory=$XDG_DATA_HOME/vim/swap//
    set backupdir=$XDG_DATA_HOME/vim/backup//

    if !has('nvim')
        set viminfo+=n$XDG_DATA_HOME/vim/viminfo
    endif
endif

if !empty($XDG_CONFIG_HOME)
    set runtimepath^=$XDG_CONFIG_HOME/vim
    set runtimepath+=$XDG_CONFIG_HOME/vim/after
    set packpath^=$XDG_CONFIG_HOME/vim
    set packpath+=$XDG_CONFIG_HOME/vim/after
endif
" }}}


if has('crypt-blowfish2')
    set cryptmethod=blowfish2
endif


filetype indent plugin on

set guifont=DejaVu\ Sans\ Mono
set background=dark

set nomodeline                                           " disable modeline parsing
set lazyredraw                                           " redraw only when we need to.

set history=1000                                         " remember more commands and search history
set undolevels=1000                                      " use many muchos levels of undo

set noerrorbells                                         " don't beep
set visualbell                                           " don't beep

set hidden
set nrformats=                                           " make <C-a> and <C-x> play well with zero-padded numbers (i.e. don't consider them octal or hex)
set virtualedit=all                                      " allow the cursor to go in to "invalid" places
set backspace=indent,eol,start                           " allow backspacing over everything in insert mode

set softtabstop=4                                        " number of spaces in tab when editing
set tabstop=4                                            " number of visual spaces per TAB
set shiftwidth=4                                         " Number of spaces to use for each step of (auto)indent
set shiftround                                           " round indent to multiple of shiftwidth when using < or >
set expandtab                                            " use space instead of tab character

set hlsearch                                             " highlight matches
set showmatch                                            " highlight matching [{()}]
set ignorecase
set incsearch                                            " search as characters are entered
set smartcase

set cursorline                                           " highlight current line
syntax on                                                " Enable syntax highlighting
set number                                               " show line numbers

set showbreak=↪\ 
set listchars=tab:»-,nbsp:␣,trail:·,extends:»,precedes:«
set list

set colorcolumn=80,120                                   " set column guides
" highlight ColorColumn ctermbg=black guibg=Black          " background color for column guides


set ruler                                                " Display the cursor position on the last line of the screen or in the status line of a window
set showcmd                                              " show command in bottom bar
set showmode                                             " always show what mode we're currently editing in
set wildmenu
set laststatus=2                                         " Always display the status line, even if only one window is displayed

set statusline=%F%m%r%h%w
set statusline+=\ [
set statusline+=ASCII=\%04.8b
set statusline+=\ \|\ 
set statusline+=HEX=\%04.4B
set statusline+=]
set statusline+=%=
set statusline+=\ [
set statusline+=%{&ft==\"\"?\"no\ ft\":&ft}
set statusline+=\ \|\ 
set statusline+=%{&ff}
set statusline+=\ \|\ 
set statusline+=%{\(&fenc==\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\",B\":\"\")\}
set statusline+=%{&endofline?'':'\ \ \|\ noeol'}
set statusline+=]
set statusline+=\ [
set statusline+=%l
set statusline+=:
set statusline+=%v
set statusline+=\/
set statusline+=%L
set statusline+=]


" Keybindings {{{
let g:mapleader = "\<Space>"

" Write as sudo
cnoremap w!! w !sudo tee % >/dev/null

" expand to the file path
cnoremap <expr> %% getcmdtype() == ':' ? fnameescape(expand('%:h')).'/' : '%%'

" Map Y to act like D and C, i.e. to yank until EOL, rather than act as yy
map Y y$

" Clear highlights
nnoremap <C-L> :nohl<CR><C-L>
nnoremap <leader><leader> :nohlsearch<CR>

" search for selected text
vnoremap // y/\V<C-R>=escape(@",'/\')<CR><CR>

" Select last inserted text
nnoremap gV `[v`]

" move by visual line
noremap j gj
noremap k gk
noremap gj j
noremap gk k
"noremap 0 g0
"noremap $ g$
onoremap j gj
onoremap k gk
onoremap gj j
onoremap gk k

" Parse modeline
nnoremap <leader>ml :setlocal invmodeline <bar> doautocmd BufRead <bar> setlocal invmodeline<CR>

" System clipboard interaction
nnoremap <F9> :set invpaste paste?<CR>
set pastetoggle=<F9>
noremap <leader>s "+
vnoremap <leader>s "+

" Apply macro from q register
nnoremap Q @q
vnoremap Q :norm @q<CR>

nnoremap <leader>q :<C-u>q!<CR>

nnoremap <leader>g :silent execute "grep! -R " . shellescape(expand("<cWORD>")) . " ."<CR>:copen<CR>
xnoremap <leader>g y :silent execute "grep! -R " . shellescape(getreg('"')) . " ."<CR>:copen<CR>

" use leader+tab to switch buffers
set wildcharm=<Tab>
nnoremap <Leader><Tab> :buffer<Space><Tab>

" Opens an edit command with the path of the currently edited file filled in
map <Leader>o :e <C-R>=expand("%:p:h") . "/" <CR>

inoremap kj <ESC>
inoremap jk <ESC>

" }}}


if has('mouse')
    set mouse=a
endif


" enable cursor change
let &t_SI.="\e[5 q"
let &t_EI.="\e[2 q"
let &t_SR.="\e[1 q"

" if exists('$TMUX')
"     let &t_SI .= "\ePtmux;\e\e[5 q\e\\"
"     let &t_EI .= "\ePtmux;\e\e[2 q\e\\"
"     let &t_ER .= "\ePtmux;\e\e[1 q\e\\"
" endif




" plugin and external things

" use leader for camel case motion plugin
let g:camelcasemotion_key = '<leader>'
"
" use rg instead of grep if available
if executable('rg')
    set grepprg=rg\ -z\ --vimgrep\ $*
    set grepformat^=%f:%l:%c:%m
    nnoremap <leader>g :silent execute "grep! -F " . shellescape(expand("<cWORD>")) . " ."<CR>:copen<CR>
    xnoremap <leader>g y :silent execute "grep! -F " . shellescape(getreg('"')) . " ."<CR>:copen<CR>
endif

let g:solarized_termcolors=256
let g:solarized_visibility="high"
silent! colorscheme solarized

packloadall
" load vim-surround keymaps for vim-sanwich
runtime macros/sandwich/keymap/surround.vim

" ctrl+p for fzf file search
if exists('g:loaded_fzf') && executable('fzf')
    nnoremap <C-p> :<C-u>FZF<CR>
    nnoremap <leader><C-p> :<C-u>FZF <C-R>=expand("%:p:h") . "/"<CR><CR>
endif

" coc.vim
if exists('g:did_coc_loaded')
    set cmdheight=2
    set signcolumn=yes
    xmap if <Plug>(coc-funcobj-i)
    xmap af <Plug>(coc-funcobj-a)
    omap if <Plug>(coc-funcobj-i)
    omap af <Plug>(coc-funcobj-a)
    nmap <silent> gd <Plug>(coc-definition)
    nmap <silent> gy <Plug>(coc-type-definition)
    nmap <silent> gi <Plug>(coc-implementation)
endif
