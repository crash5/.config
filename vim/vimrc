" vim: foldmethod=marker

if &compatible
    set nocompatible
endif

let g:mapleader = "\<Space>"

filetype indent plugin on

set viminfo='100,<1000,s100,h

" XDG path config {{{
if !empty($XDG_DATA_HOME)
    set undodir=$XDG_DATA_HOME/vim/undo//
    set directory=$XDG_DATA_HOME/vim/swap//
    set backupdir=$XDG_DATA_HOME/vim/backup//
    set viewdir=$XDG_DATA_HOME/vim/views//

    if !has('nvim')
        set viminfo+=n$XDG_DATA_HOME/vim/viminfo
    endif
endif

if !empty($XDG_CONFIG_HOME)
    set runtimepath^=$XDG_CONFIG_HOME/vim
    set runtimepath+=$XDG_CONFIG_HOME/vim/after
    set packpath^=$XDG_CONFIG_HOME/vim
    set packpath+=$XDG_CONFIG_HOME/vim/after
endif
" }}}

" Security {{{
if has('crypt-blowfish2')
    set cryptmethod=blowfish2
endif

set nomodeline                                           " disable modeline parsing
set modelines=2
" parse modeline with keybinding
nnoremap <leader>ml :setlocal modeline <bar> doautocmd BufRead <bar> setlocal nomodeline<CR>
" }}}

" Display {{{
set guifont=DejaVu\ Sans\ Mono

if !has('nvim')
    " set Vim-specific sequences for RGB colors
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif
set termguicolors

set background=dark
syntax on                                                " Enable syntax highlighting

set lazyredraw                                           " redraw only when we need to.

set showbreak=↪\ 
set listchars=tab:»-,nbsp:␣,trail:·,extends:»,precedes:«
set list
set linebreak                                            " don't cut words into pieces on line break

set colorcolumn=80,120                                   " set column guides
set cursorline                                           " highlight current line
set number                                               " show line numbers
set ruler                                                " Display the cursor position on the last line of the screen or in the status line of a window
set showcmd                                              " show command in bottom bar
set showmode                                             " always show what mode we're currently editing in
" }}}

" Other (history, bell, mouse) {{{
set history=1000                                         " remember more commands and search history
set undolevels=1000                                      " use many muchos levels of undo
set undofile                                             " enable persistent undo

set wildmenu
set wildmode=longest:full,full                           " autocomplete to common substr and iterate over resulst

set noerrorbells                                         " don't beep
set visualbell                                           " don't beep

if has('mouse')
    set mouse=a
endif
" }}}

" Operation {{{
set hidden
set nrformats=                                           " make <C-a> and <C-x> play well with zero-padded numbers (i.e. don't consider them octal or hex)
" set virtualedit=all                                      " allow the cursor to go in to "invalid" places
set backspace=indent,eol,start                           " allow backspacing over everything in insert mode

" More natural split directions
set splitbelow
set splitright

" :find look for files in sub-directories
set path+=**
" }}}

" Whitespace {{{
set softtabstop=4                                        " number of spaces in tab when editing
set tabstop=4                                            " number of visual spaces per TAB
set shiftwidth=4                                         " Number of spaces to use for each step of (auto)indent
set shiftround                                           " round indent to multiple of shiftwidth when using < or >
set expandtab                                            " use space instead of tab character
" }}}

" Search/Replace {{{
set hlsearch                                             " highlight matches
set showmatch                                            " highlight matching [{()}]
set ignorecase
set incsearch                                            " search as characters are entered
set smartcase

" Clear highlights
nnoremap <leader><leader> :nohlsearch<CR>

" search word under cursor or selected text
nnoremap <leader>g :silent execute "grep! -R " . shellescape(expand("<cWORD>")) . " ."<CR>:copen<CR>
xnoremap <leader>g y :silent execute "grep! -R " . shellescape(getreg('"')) . " ."<CR>:copen<CR>

" search for selected text
vnoremap // y/\V<C-R>=escape(@",'/\')<CR><CR>

" search and replace word/selection
nnoremap <Leader>cc :%s/\<<C-r><C-w>\>/<C-r><C-w>
vnoremap <Leader>cc y:%s/<C-r>"/<C-r>"

command! ClearQuickfixList cexpr []
" }}}

" Statuline {{{
set laststatus=2                                         " Always display the status line, even if only one window is displayed
set statusline=%F%m%r%h%w
set statusline+=\ [
set statusline+=ASCII=\%04.8b
set statusline+=\ \|\ 
set statusline+=HEX=\%04.4B
set statusline+=]
set statusline+=%=
set statusline+=\ [
set statusline+=%{&ft==\"\"?\"no\ ft\":&ft}
set statusline+=\ \|\ 
set statusline+=%{&ff}
set statusline+=\ \|\ 
set statusline+=%{\(&fenc==\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\",B\":\"\")\}
set statusline+=%{&endofline?'':'\ \ \|\ noeol'}
set statusline+=]
set statusline+=\ [
set statusline+=%l
set statusline+=:
set statusline+=%v
set statusline+=\/
set statusline+=%L
set statusline+=]
" }}}

" System clipboard interaction {{{
nnoremap <F9> :set invpaste paste?<CR>
set pastetoggle=<F9>
noremap <leader>s "+
vnoremap <leader>s "+
noremap <leader>ss :let @+=@"<CR>
" }}}

" Other keybindings {{{

inoremap kj <ESC>
inoremap jk <ESC>

noremap <leader>q :<C-u>q!<CR>
noremap <leader>Q :<C-u>qall!<CR>

" Map Y to act like D and C, i.e. to yank until EOL, rather than act as yy
noremap Y y$

" move by visual line
noremap j gj
noremap k gk
noremap gj j
noremap gk k
onoremap j gj
onoremap k gk
onoremap gj j
onoremap gk k

" Select last inserted text
nnoremap gV `[v`]

" Opens an edit command with the path of the currently edited file filled in
map <Leader>o :e <C-R>=expand("%:p:h") . "/" <CR>

" use leader+tab to switch buffers
set wildcharm=<Tab>
nnoremap <Leader><Tab> :buffer<Space><Tab>

" expand to the file path
cnoremap <expr> %% getcmdtype() == ':' ? fnameescape(expand('%:h')).'/' : '%%'

" Write as sudo
cnoremap w!! w !sudo tee % >/dev/null

" Apply macro from q register
nnoremap Q @q
vnoremap Q :normal @q<CR>

vnoremap <leader>. :normal .<CR>

" reload file, discard any chagnes
nnoremap <F5> :<C-u>edit!<CR>
" }}}

" Terminal cursor change support {{{
if exists("&t_SI") | let &t_SI.="\e[5 q" | endif
if exists("&t_EI") | let &t_EI.="\e[2 q" | endif
if exists("&t_SR") | let &t_SR.="\e[1 q" | endif

" if exists('$TMUX')
"     let &t_SI .= "\ePtmux;\e\e[5 q\e\\"
"     let &t_EI .= "\ePtmux;\e\e[2 q\e\\"
"     let &t_ER .= "\ePtmux;\e\e[1 q\e\\"
" endif
" }}}

" Plugins and external things {{{

" CamelCase motion {{{
let g:camelcasemotion_key = '<leader>'
" }}}

" Ripgrep {{{
" use rg instead of grep if available
if executable('rg')
    set grepprg=rg\ --search-zip\ --follow\ --hidden\ --vimgrep\ $*
    set grepformat^=%f:%l:%c:%m
    nnoremap <leader>g :silent execute "grep! -F " . shellescape(expand("<cWORD>")) . " ."<CR>:copen <BAR> redraw!<CR>
    xnoremap <leader>g y :silent execute "grep! -F " . shellescape(getreg('"')) . " ."<CR>:copen <BAR> redraw!<CR>
endif
" }}}

" Solarized color scheme {{{
" let g:solarized_termcolors=256
let g:solarized_visibility="high"
let g:solarized_extra_hi_groups=1
silent! colorscheme solarized8
" }}}

if exists(":packloadall")
    packloadall
endif

" Sandwitch / Surround {{{
" load vim-surround keymaps for vim-sanwich
if exists('g:loaded_sandwich')
    runtime macros/sandwich/keymap/surround.vim
endif

" surround current word
if exists('g:loaded_sandwich') || exists('g:loaded_surround')
    nmap <leader>' ysiw'
    nmap <leader>" ysiw"
endif
" }}}

" Fzf {{{
" ctrl+p for fzf file search
if exists('g:loaded_fzf') && executable('fzf')
    nnoremap <C-p> :<C-u>FZF<CR>
    nnoremap <leader><C-p> :<C-u>FZF <C-R>=expand("%:p:h") . "/"<CR><CR>
endif
" }}}

" coc.vim {{{
if exists('g:did_coc_loaded')
    set cmdheight=2
    set signcolumn=yes

    inoremap <silent><expr> <NUL> coc#refresh()
    inoremap <silent><expr> <c-space> coc#refresh()

    " Use K to show documentation in preview window
    nnoremap <silent> K :call <SID>show_documentation()<CR>
    function! s:show_documentation()
      if (index(['vim','help'], &filetype) >= 0)
        execute 'h '.expand('<cword>')
      else
        call CocAction('doHover')
      endif
    endfunction

    nmap <leader>rn <Plug>(coc-rename)

    xmap <leader>f  <Plug>(coc-format-selected)
    nmap <leader>f  <Plug>(coc-format-selected)

    xmap if <Plug>(coc-funcobj-i)
    omap if <Plug>(coc-funcobj-i)
    xmap af <Plug>(coc-funcobj-a)
    omap af <Plug>(coc-funcobj-a)
    xmap ic <Plug>(coc-classobj-i)
    omap ic <Plug>(coc-classobj-i)
    xmap ac <Plug>(coc-classobj-a)
    omap ac <Plug>(coc-classobj-a)

    nmap <silent> gd <Plug>(coc-definition)
    nmap <silent> gy <Plug>(coc-type-definition)
    " nmap <silent> gi <Plug>(coc-implementation)
endif
" }}}

" }}}

" local changes {{{
if filereadable(expand("~/.local/vimrc"))
    source ~/.local/vimrc
endif
" }}}
